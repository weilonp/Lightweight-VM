/* DO NOT EDIT THIS FILE
 * - vm_cs.c (KAIA VM)
 * - Copyright: Prof. Kevin Andrea, George Mason University.  All Rights Reserved
 * - Date: Jan 2022
 */

// System Includes
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <pthread.h>
#include <sched.h>
// Local Includes
#include "vm_cs.h"
#include "vm_support.h"
#include "vm_process.h"
#include "vm_printing.h"
#include "vm_schedule.h"

// Globals
pthread_mutex_t cs_cv_m = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t cs_run_m = PTHREAD_MUTEX_INITIALIZER;
pthread_t pt_cs; // Main CS thread variable (controlled from atexit function)
static process_node_t *on_cpu = NULL;
static schedule_header_t *schedule = NULL;
static int cs_do_cs = 1; // Controls the lifetime CS Thread
static int cs_run = 0; // Controls the running of the CS Thread (initialized to STOP)
static char g_status_msg[MAX_STATUS] = {0};
static useconds_t sleep_usec_time = SLEEP_USEC;
static useconds_t between_usec_time = BETWEEN_USEC;

// Runs at VM startup to initialize context switching thread
void initialize_cs_system() {
  // Start the CS Thread Locked by...
  // 1) Acquiring the lock here on initialization
  // 2) Each iteration of the CS thread starts by acquiring the lock.
  // The Shell commands release/acquire the lock to control CS
  pthread_mutex_lock(&cs_cv_m);

  int ret = pthread_create(&pt_cs, NULL, &cs_thread, NULL);
  if(ret != 0) {
    abort_error("Could not create a Thread for the CS System.", __FILE__);
  }
  // Initialize the Scheduler System (this is designed as a part of CS)
  schedule = schedule_create();
  if(schedule == NULL) {
    abort_error("Failed to initialize the Scheduler System (schedule_create returned NULL).", __FILE__);
  }
}

// Called on an atexit to free all CS related memory.
void cs_cleanup() {
  print_status("... Beginning CS Shutdown");
  print_status("... Deallocating Scheduler");
  schedule_deallocate(schedule);
  print_status("... Shutting Down CS System and Dispatcher");
  cs_do_cs = 0; // Tell the thread to die.
  pthread_mutex_unlock(&cs_cv_m); // If the CS is not running, activate it so it can die.
  pthread_join(pt_cs, NULL);
  print_status("... Removing Process from CPU");
  free(on_cpu);
  on_cpu = NULL; // Nothing on CPU.
  print_status("... CS Shutdown Complete");
}

// Context Switching Thread
void *cs_thread(void *args) {
  int iteration = 1;
// 1) While not blocked... (lock cs_cv_m to block)
// .. a) Gets the next process to run from the Scheduler (select)
// .. .. Holds this in the on_cpu global
// .. b) Resumes the selected process
// .. c) Sleeps for sleep_usec_time microseconds
// .. d) Suspends the selected process
// .. e) Returns the process to the Scheduler (insert)
  while(cs_do_cs) {
    pthread_mutex_lock(&cs_cv_m);  // mylock.acquire()  -- Turnstile Pattern
    pthread_mutex_unlock(&cs_cv_m);// mylock.release()
    // Check to see if the system is being shutdown while waiting on lock.
    if(cs_do_cs == 0) {
      continue; 
    }
    sprintf(g_status_msg, "Context Switch: Iteration %d", iteration++);
    print_debug(g_status_msg);
    on_cpu = schedule_select(schedule);
    // Only Dispatch if something was selected
    if(on_cpu != NULL) {
      if(process_find(on_cpu->pid) == 0) {
        schedule_exit(schedule, on_cpu, 42);
        on_cpu = NULL;
      }
      else {
        sprintf(g_status_msg, "Schedule Select Returned PID %d", on_cpu->pid);
        print_debug(g_status_msg);
        kill(on_cpu->pid, SIGCONT);
        usleep(sleep_usec_time);
        // Process may have exited and already been cleaned up.  Check if still exists first.
        if(on_cpu) {
          kill(on_cpu->pid, SIGTSTP);
          schedule_insert(schedule, on_cpu);
          on_cpu = NULL;
        }
      }
    }
    // Nothing selected, IDLE CPU
    else {
      print_debug("Schedule Select Returned Nothing");
      usleep(sleep_usec_time);
      // Unnecessary with the sleep... sched_yield(); // Tells Linux to switch threads
    }
    // Delay after the run quantum, but before we pick a new one (to help with debugging)
    usleep(between_usec_time);
  }
  pthread_exit(0);
}

// Directs the Scheduler to suspend a process from execution
void cs_suspend(pid_t pid) {
  int last_state = -1;

  // There IS a race condition here, but it's a pretty minor one.  
  // If it WAS running when we shut it off, restart it when we finish.
  // It's possible they shut it off manually in the microseconds between these,
  // but it's not exactly the end of the world if they had.
  pthread_mutex_lock(&cs_run_m);
  last_state = cs_run;
  pthread_mutex_unlock(&cs_run_m);
  stop_cs(); // Critical!  This ensures that all processes have been returned to Scheduler first
  print_debug("Suspending Process Now");
  schedule_suspend(schedule, pid);
  if(last_state == 1) {
    start_cs();
  }
}

// Directs the Scheduler to resume a process from execution
void cs_resume(pid_t pid) {
  int last_state = -1;

  // There IS a race condition here, but it's a pretty minor one.  
  // If it WAS running when we shut it off, restart it when we finish.
  // It's possible they shut it off manually in the microseconds between these,
  // but it's not exactly the end of the world if they had.
  pthread_mutex_lock(&cs_run_m);
  last_state = cs_run;
  pthread_mutex_unlock(&cs_run_m);
  stop_cs(); // Critical!  This ensures that all processes have been returned to Scheduler first
  print_debug("Resuming Process Now");
  schedule_resume(schedule, pid);
  if(last_state == 1) {
    start_cs();
  }
}

// Returns the process that was on the CPU back to the Scheduler
void cs_exiting_process(int exit_code) {
  if(on_cpu) {
    int exit = 0;
    exit = schedule_exit(schedule, on_cpu, exit_code);
    sprintf(g_status_msg, "Terminating PID %d, got back exit code %d from schedule_exit\n", on_cpu->pid, exit);
    print_debug(g_status_msg);
    on_cpu = NULL;
  }
  else {
    print_warning("Tried to exit a non-existing process on the CPU");
  }
}

// Adds the newly created process to the schedule system
void cs_schedule_process(process_data_t *proc) {
  process_node_t *proc_node = schedule_new_process(proc->cmd, proc->pid, proc->is_sudo);
  schedule_insert(schedule, proc_node);
  print_schedule_debug(schedule);
}

// Tells the schedule to terminate the process with the given exit code
void cs_schedule_terminate(pid_t pid, int exit_code) {
  int last_state = -1;
  int exit = 0;

  // There IS a race condition here, but it's a pretty minor one.  
  // If it WAS running when we shut it off, restart it when we finish.
  // It's possible they shut it off manually in the microseconds between these,
  // but it's not exactly the end of the world if they had.
  pthread_mutex_lock(&cs_run_m);
  last_state = cs_run;
  pthread_mutex_unlock(&cs_run_m);
  stop_cs(); // Critical! This ensures the state is consistent first.
  if(on_cpu && on_cpu->pid == pid) {
    // Exit from the CPU directly (terminated while being run)
    cs_exiting_process(exit_code);
  }
  else {
    // Exit from the Ready or Suspended Queues (terminated by command)
    exit = schedule_terminate(schedule, pid, exit_code);
    sprintf(g_status_msg, "Terminating PID %d, got back exit code %d from schedule_terminate\n", pid, exit);
    print_debug(g_status_msg);
  }
  if(last_state == 1) {
    start_cs();
  }
} 

// Prints the full Schedule of all processes being tracked.
void print_schedule() {
  print_status("Printing the current Schedule Status...");
  sprintf(g_status_msg, "...[Ready Queue - %d Processes]", schedule_get_size(schedule->ready_queue));
  print_status(g_status_msg);
  print_schedule_queue(schedule->ready_queue);
  sprintf(g_status_msg, "...[Suspended Queue - %d Processes]", schedule_get_size(schedule->suspended_queue));
  print_status(g_status_msg);
  print_schedule_queue(schedule->suspended_queue);
  sprintf(g_status_msg, "...[Defunct Queue - %d Processes]", schedule_get_size(schedule->defunct_queue));
  print_status(g_status_msg);
  print_schedule_queue(schedule->defunct_queue);
}

// Prints a single Scheduler Queue
void print_schedule_queue(queue_header_t *queue) {
  process_node_t *walker = queue->head;
  while(walker != NULL) {
    print_process_node(walker);
    walker = walker->next;
  }
}

// Prints a schedule tracked process
void print_process_node(process_node_t *node) {
  if((node->flags >> 29)&1) {
    sprintf(g_status_msg, "     [PID :%d] %s (Exit Code: %d)", node->pid, node->cmd, (node->flags)&0xFFFFFFF);
  }
  else {
    sprintf(g_status_msg, "     [PID :%d] %s", node->pid, node->cmd);
  }
  print_status(g_status_msg);
}

// Starts the CS Processing
void start_cs() {
  sprintf(g_status_msg, "Starting CS System: %d usec Run, %d usec Between", sleep_usec_time, between_usec_time);
  print_status(g_status_msg);
  pthread_mutex_lock(&cs_run_m);
  if(cs_run == 0) {
    cs_run = 1;
    pthread_mutex_unlock(&cs_cv_m);
  }
  pthread_mutex_unlock(&cs_run_m);
}

// Stops the CS Processing
void stop_cs() {
  print_status("Stopping CS System");
  pthread_mutex_lock(&cs_run_m);
  if(cs_run == 1) {
    cs_run = 0;
    pthread_mutex_lock(&cs_cv_m);
  }
  pthread_mutex_unlock(&cs_run_m);
}

// Toggles the CS Processing
void toggle_cs() {
  pthread_mutex_lock(&cs_run_m);
  int is_running = cs_run;
  pthread_mutex_unlock(&cs_run_m);
  if(is_running) {
    stop_cs();
  }
  else {
    start_cs();
  }
}

// Returns the state AS OF THE TIME OF CALLING of the CS System
void print_cs_status() {
  pthread_mutex_lock(&cs_run_m);
  int state = cs_run;
  pthread_mutex_unlock(&cs_run_m);
  if(state == 1) {
    sprintf(g_status_msg, "CS System Running: runtime %d usec, delaytime %d usec", sleep_usec_time, between_usec_time);
    print_status(g_status_msg);
  }
  else {
    sprintf(g_status_msg, "CS System Stopped: runtime %d usec, delaytime %d usec", sleep_usec_time, between_usec_time);
    print_status(g_status_msg);
  }
  return;
}

// Set the time for each process to run for (Quantum)
void set_run_usec(useconds_t time) {
  sleep_usec_time = time;
  sprintf(g_status_msg, "Setting CS System: runtime %d usec, delaytime %d usec", sleep_usec_time, between_usec_time);
  print_status(g_status_msg);
}

// Set the time between processes running
void set_between_usec(useconds_t time) {
  between_usec_time = time;
  sprintf(g_status_msg, "Setting CS System: runtime %d usec, delaytime %d usec", sleep_usec_time, between_usec_time);
  print_status(g_status_msg);
}

