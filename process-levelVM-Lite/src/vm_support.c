/* DO NOT EDIT THIS FILE
 * - vm_support.c (KAIA VM)
 * - Copyright: Prof. Kevin Andrea, George Mason University.  All Rights Reserved
 * - Date: Jan 2022
 */

// System Includes
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
// Project Includes
#include "vm_settings.h"
#include "vm_shell.h"
#include "vm_printing.h"
#include "vm_support.h"

static char g_status_msg[MAX_STATUS] = {0};

// Quickly registers a new signal with the given signal number and handler
void register_signal(int sig, void (*handler)(int)) {
  if(handler == NULL) {
    abort_error("Handler Function Needed for Registration", __FILE__);
  }

  struct sigaction sa = {0};
  sa.sa_handler = handler;
  sigaction(sig, &sa, NULL);
}

// Print the Virtual System Prompt
void print_prompt() {
  printf("%s(PID: %d)%s %s%s%s ", BLUE, getpid(), RST, GREEN, PROMPT, RST);
  fflush(stdout);
}

// Prints out Status Messages
void print_status(char *msg) {
  printf("  %s[Status] %s%s\n", YELLOW, msg, RST);
}

// Prints out Debug Messages
void print_debug(char *msg) {
  if(debug_mode == 1) {
    printf("  %s[Debug ] %s%s\n", CYAN, msg, RST);
  }
}

// Prints out all the Warning Messages
void print_warning(char *msg) {
  fprintf(stderr, "  %s[Warn  ] %s%s\n", MAGENTA, msg, RST);
}

// Special Error that also immediately exits the program.
void abort_error(char *msg, char *src) {
  fprintf(stderr, "  %s[ERROR ] %s%s\n", RED, msg, RST);
  fprintf(stderr, "  %sTerminating Program%s\n", RED, RST);
  exit(EXIT_FAILURE);
}

// Prints out the Opening Banner
void print_kaia_banner() {
  printf(
" %sGreen Imperial HEx:%s %sKAIA VM v1.5a%s Trial %s*EXPIRED*%s\n%s"
"          [o]              \n"
" ._________|__________.    \n"
" | |  /  ^^  =+=  ^^  |    \n"
" | | /  /  |  |  /  | |    \n"
" | |<   +--+  |  +--+ |    \n"
" | | |  |  |  |  |  | |    \n"
" | |  | |  | =+= |  | |    \n"
" |                    |    \n"
" | %s[KAIA-VM] $%s _      |\n"
" .____________________.    \n"
"          [  ]             \n"
" ._________++_________.  %s\n", GREEN, RST, BLUE, RST, RED, RST, YELLOW, GREEN, YELLOW, RST);
}

// Prints the full Schedule of all processes being tracked.
void print_schedule_debug(schedule_header_t *schedule) {
  if(schedule == NULL) {
    print_debug("Schedule is not Initialized Yet.");
    return;
  }
  print_debug("Printing the current Schedule Status...");
  sprintf(g_status_msg, "...[Ready Queue - %d Processes]", schedule_get_size(schedule->ready_queue));
  print_debug(g_status_msg);
  print_schedule_queue_debug(schedule->ready_queue);
  sprintf(g_status_msg, "...[Suspended Queue - %d Processes]", schedule_get_size(schedule->suspended_queue));
  print_debug(g_status_msg);
  print_schedule_queue_debug(schedule->suspended_queue);
  sprintf(g_status_msg, "...[Defunct Queue - %d Processes]", schedule_get_size(schedule->defunct_queue));
  print_debug(g_status_msg);
  print_schedule_queue_debug(schedule->defunct_queue);
}

// Prints a single Scheduler Queue
void print_schedule_queue_debug(queue_header_t *queue) {
  process_node_t *walker = queue->head;
  while(walker != NULL) {
    print_process_node_debug(walker);
    walker = walker->next;
  }
}

// Prints a schedule tracked process
void print_process_node_debug(process_node_t *node) {
  if((node->flags>>29)&1) {
    sprintf(g_status_msg, "     [PID :%d] %s (Exit Code: %d)", node->pid, node->cmd, (node->flags)&0xFFFFFFF);
  }
  else {
    sprintf(g_status_msg, "     [PID :%d] %s", node->pid, node->cmd);
  }
  print_debug(g_status_msg);
}

